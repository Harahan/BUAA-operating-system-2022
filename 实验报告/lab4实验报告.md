# lab4实验报告

**黄雨石20376156**

[toc]

## 实验思考题

### Thinking4.1

- **内核在保存现场的时候是如何避免破坏通用寄存器的？**
- **系统陷入内核调用后可以直接从当时的$a0-\$a3参数寄存器中得到用户调用msyscall留下的信息吗？**
- **我们是怎么做到让sys开头的函数“认为”我们提供了和用户调用msyscall时同样的参数的？**
- **内核处理系统调用的过程对Trapframe做了哪些更改？这种修改对应的用户态的变化是？**

**answer:**1）内核使用宏函数`SAVE_ALL`来保存现场，在该函数的代码实现里，只使用了\$k0和\$k1两个通用寄存器来进行操作，从而保证其他通用寄存器的值都不会被改变。2）用户在调用`msyscall`时，传入的参数会被保存在\$a0-\$a3寄存器和堆栈中。当陷入内核时，\$a0-\$a3寄存器不会被破坏，而且用户栈中的内容会被原封不动地被拷贝到内核栈（`KERNEL_SP`）中。因此，`sys_*`函数可以从寄存器和用户栈获得"用户调用`msyscall`时传入的参数值"。3）在处理过程中，将`Trapframe`中`epc`的值进行了一定处理，同时将`sys_*`函数的返回值存入`Trapframe`中的`v0`寄存器中。这种修改保证在进入用户态时，用户程序能够从正确的位置正确运行，同时也使得用户程序从`v0`寄存器中获得系统调用的返回值。

### Thinking4.2

**思考下面的问题，并对这个问题谈谈你的理解： 请回顾 lib/env.c 文件中 mkenvid() 函数的实现，该函数不会返回 0，请结合系统调用和 IPC 部分的实现 与 envid2env() 函数的行为进行解释。**

**answer:**``mkenvid``中：

```c
u_int mkenvid(struct Env *e) {
    u_int idx = e - envs;
    u_int asid = asid_alloc();
    return (asid << (1 + LOG2NENV)) | (1 << LOG2NENV) | idx;
}
```

``envid``第10位永远是1，即保证生成的所有``envid``一定是非0的

而在``envid2env``中：

```c
int envid2env(u_int envid, struct Env **penv, int checkperm)
{
    struct Env *e;
    /* Hint: If envid is zero, return curenv.*/
    /* Step 1: Assign value to e using envid. */
    if (envid == 0) {
        *penv = curenv;
        return 0;
    }
	// ...
}
```

可以发现，**当`envid`的值是0时，函数会返回指向当前进程控制块的指针**（通过形参`penv`返回）。当某些系统调用函数需要访问当前进程的进程控制块时，可以直接通过向`mkenvid`传0来会获得指向当前进程控制块的指针，然后通过指针对进程控制块进行访问。

因此，**0作为`envid`的保留值是为了方便程序直接通过`envid2env`函数来访问当前进程的进程控制块。**

### Thinking4.3

**思考下面的问题，并对这两个问题谈谈你的理解：**

- **子进程完全按照 fork() 之后父进程的代码执行，说明了什么？**
- **但是子进程却没有执行 fork() 之前父进程的代码，又说明了什么？**

**answer:前者说明子进程的代码段和父进程是完全一样的；后者说明子进程的初始上下文位置是在`fork`函数**，也就是说，子进程的初始`PC`并不是在用户程序的入口，而是在父进程`EPC`指向的位置

### Thinking4.4

 **关于 fork 函数的两个返回值，下面说法正确的是：**

- **A、fork 在父进程中被调用两次，产生两个返回值**
- **B、fork 在两个进程中分别被调用一次，产生两个不同的返回值**
- **C、fork 只在父进程中被调用了一次，在两个进程中各产生一个返回值**
- **D、fork 只在子进程中被调用了一次，在两个进程中各产生一个返回值**

**answer:**在`fork`函数中子进程被创建，而当子进程被调度时，恢复的上下文环境仍然是在`fork`函数中（实际上是`syscall_env_alloc`函数之后），因此``fork``只在父进程中被调用一次，子进程恢复上下文后，由于设置的返回值是0所以直接从``fork``函数中返回了，此外，执行完`fork`函数后，父进程返回的是子进程的`envid`，子进程返回的是0，因此父子进程的返回值是不同的。综上，答案为C。

### Thinking4.5

**我们并不应该对所有的用户空间页都使用duppage进行映射。那么究竟哪些用户空间页应该映射，哪些不应该呢？ 请结合本章的后续描述、mm/pmap.c 中 mips_vm_init 函数进行的页面映射以及 include/mmu.h 里的内存布局图进行思考。**

**answer:**`UTOP`和`TLIM`之间储存的是**和内核相关的页表信息**。在执行`env_alloc()`函数时，这一部分的映射关系直接从`boot_pgdir`拷贝到进程页表中，因此不需要进行映射。

`UTOP`和`USTACKTOP`之间是**异常处理栈（user exception stack）和无效内存（invalid memory）**，前者是进行异常处理的地方， 后者一般也不会用到，所以父子进程不需要共享这部分的内存，也就不需要进行映射了。

所以，最终需要被映射的页面**只有`USTACKTOP`之下的部分**。

### Thinking4.6

 **在遍历地址空间存取页表项时你需要使用到vpd和vpt这两个“指针的指针”，请参考 user/entry.S 和 include/mmu.h 中的相关实现，思考并回答这几个问题：**

- **vpt和vpd的作用是什么？怎样使用它们？**
- **从实现的角度谈一下为什么进程能够通过这种方式来存取自身的页表？**
- **它们是如何体现自映射设计的？**
- **进程能够通过这种方式来修改自己的页表项吗？**

**answer:**1）`vpt`和`vpd`分别是指向用户页表和用户页目录的指针，可以用来对用户页表和页目录进行访问。在使用的时候，以`vpt`为例，先用`*`运算符获得页表基地址（此时获得的是一个地址还是相当于一个指针），然后从要访问的虚拟地址中获得页表项相对基地址的偏移作为数组下标，页表基地址作为一个数组地址，这样我们就可以像访问一个数组那样来对页表项进行访问。vpd同理。2）在`entry.S`中我们可以找到`vpt`和`vpd`的定义——

```c
vpt:
	.word UVPT

	.globl vpd
vpd:
	.word (UVPT+(UVPT>>12)*4)
```

可以发现，`vpt`和`vpd`分别指向了两个值——`UVPT`和`(UVPT+(UVPT>>12)*4)`，这两个值分别是用户地址空间中页表的首地址和页目录的首地址。所以我们可以直接通过`vpt`和`vpd`访问到用户进程页表和页目录。3）上面说到，`vpd`的值是`(UVPT+(UVPT>>12)*4)`，而这个地址正好在`UVPT`和`UVPT+PDMAP`之间，说明页目录被映射到了某一个页表的位置。我们知道，每一个页表都被页目录中的一个页表项所映射。因此"页目录被映射到某一个页表的位置"就意味着，**在页目录中一定有一个页表项映射到了页目录本身**，即实现了自映射。4）不能，页表是内核态程序维护的，用户进程只能对页表项其进行访问，而不能对其进行修改。

### Thiinking4.7

 **page_fault_handler 函数中，你可能注意到了一个向异常处理栈复制Trapframe运行现场的过程，请思考并回答这几个问题：**

- **这里实现了一个支持类似于“中断重入”的机制，而在什么时候会出现这种“中断重入”？**
- **内核为什么需要将异常的现场Trapframe复制到用户空间？**

**answer:**1）当发生缺页中断时如果在发生其他中断（比如时钟中断），就会出现中断重入。2）因为异常的处理是在用户态进行的，而**用户态只能访问用户空间（低2G空间）内的数据**，所以需要将现场保存在用户空间。

### Thinking4.8

**到这里我们大概知道了这是一个由用户程序处理并由用户程序自身来恢复运行现场的过程，请思考并回答以下几个问题：**

- **在用户态处理页写入异常，相比于在内核态处理有什么优势？**
- **从通用寄存器的用途角度讨论，在可能被中断的用户态下进行现场的恢复，要如何做到不破坏现场中的通用寄存器？**

**answer:**1）尽量减少内核出现错误的可能，即使程序崩溃，也不会影响系统的稳定。同时微内核的模式下，用户态进行新页面的分配映射也更加灵活方便。2）在进入用户态的异常处理程序前，将通用寄存器中的值存储在一个特殊的栈空间——**异常处理栈**；执行完异常处理程序后，在从异常处理栈恢复到通用寄存器。

### Thinking4.9

**请思考并回答以下几个问题：**

- **为什么需要将set_pgfault_handler的调用放置在syscall_env_alloc之前？**
- **如果放置在写时复制保护机制完成之后会有怎样的效果？**
- **子进程是否需要对在entry.S定义的字__pgfault_handler赋值？**

**answer:**1）其实`set_pgfault_handler`并不一定要置在`syscall_env_alloc`之前， 只要放在“写时复制机制建立”之前即可。理由如下——
我们知道，在子进程真正运行之前，父进程会将需要与子进程共享的页面共享给子进程，并同时设置写时复制机制。在这个过程中，**父进程数据段里的全局变量也就变成了子进程的全局变量**，因此只要在此之前父进程的`__pgfault_handler`已经被赋值过，那么设置完写时复制机制之后，子进程中`__pgfault_handler`的值就同样被"赋值"了（和父进程保持一致）
**因此，`set_pgfault_handler`必须在”写时复制机制“完成之前。**`set_pgfault_handler`无论是放`syscall_env_alloc`之前还是之后，其实都没有问题。
但是如果非要问为什么”`set_pgfault_handler`的调用放置在`syscall_env_alloc`之前“，大概是因为，这样可以节省子进程的运行时间，因为子进程是在"**`syscall_env_alloc`的执行刚刚从内核态返回用户态**"的时候开始运行的。

2）通过上面的解释可以知道，如果将`set_pgfault_handler`放置在写时复制保护机制完成之后，那么**子进程中的全局变量`__pgfault_handler`就不会被赋值**，那么页写入异常处理机制也就无法被建立起来。

3）不需要，因为父进程已经通过`set_pgfault_handler`函数将`__pgfault_handler`赋值为`pgfault`的函数地址了，并且在写时复制机制建立时将数据段里的全局变量都"复制"到了子进程的数据段（包括`__pgfault_handler`），因此子进程不需要再对其进行赋值。

## 实验难点图示

主要包括3个难点

- **系统调用的处理流程**
- **页写入异常处理机制的建立**
- **页写入异常处理流程**

1）系统调用的处理流程和时钟中断的处理流程相似：用户使用系统调用后，CPU进入内核态，并通过异常分发程序的分发进入到了异常服务函数`handle_sys`。然后，`handle_sys`函数根据传入的系统调用号跳转到具体的处理函数`sys_*`。经过一系列处理，最后返回用户态。整个流程如下图所示——

![image-20220520180136471](C:\Users\hys\AppData\Roaming\Typora\typora-user-images\image-20220520180136471.png)

2）为建立起页写入异常处理机制，我们需要完成以下三个任务——

- 为进程的异常处理栈分配物理页面
- 将进程控制块的异常处理栈地址设置为`UXSTACKTOP`，将异常处理函数地址设置为`__asm_pgfault_handle`
- 将全局变量`__pgfault_handler`赋值为`pgfault`函数的地址

因为父子进程都需要建立页写入异常处理机制，所以两者都需要完成上述的三个任务，即总共有6个任务。而这6个任务都由父进程通过fork函数完成的，具体过程如下——

![image-20220520180506518](C:\Users\hys\AppData\Roaming\Typora\typora-user-images\image-20220520180506518.png)

3）建立起页写入异常处理机制后，我们的操作系统就有了处理该异常的能力。每当写入`PTE_COW`为1的页面时，页写入异常就会被触发，处理流程如下所示——

![image-20220520180557384](C:\Users\hys\AppData\Roaming\Typora\typora-user-images\image-20220520180557384.png)

## 体会与感想

本次实验加上理解代码大概花费了10来个钟，可以说这次实验的难度比``lab3``高了不少，但是对于``lab3``中有关进程的函数有了进一步的理解，同时对于异常处理也理解的更加深刻了，特别是为什么要用``kernel_stack``和``time_stack``两个栈这个问题。而此次``lab4``中的系统调用与``fork``我也画了大量时间去看代码与指导书，对他们也有了一定的理解，随着操作系统实验进行到``lab4``，感觉自己正在逐渐摸清楚一个建议的操作系统是怎样运作的了，希望下个``lab``继续努力

